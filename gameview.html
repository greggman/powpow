<!doctype html>
<html>
<head>
<title>PowPow</title>
<style>
html, body {
  width: 100%;
  height: 100%;
  border: 0px;
  padding: 0px;
  margin: 0px;
  background-color: black;
  font-family: sans-serif;
}
#outer {
  width: 100%;
  height: 100%;
}
#canvas {
  float: left;
  width: 85%;
  height: 100%;
}
#status {
  float: right;
  width: 15%;
  background-color: red;
  height: 100%;
}
#highscores-outer {
  width: 100%;
  height: 50%;
  background-color: blue;
}
#highscores-outer {
  width: 100%;
  height: 50%;
  background-color: blue;
}
</style>
<!-- Note: Socket IO is served from the socket io based server -->
<script type="text/javascript" src="socket.io/socket.io.js"></script>
<script type="text/javascript" src="tdl/base.js"></script>
<script>
tdl.require('tdl.log');
tdl.require('tdl.webgl');

window.onload = main;

var g_maxActivePlayers = 3;
var g_playerCount = 1;
var g_totalPlayerCount = 0;
var g_canvas;
var g_ctx;
var g_clock;
var g_socket;
var g_players = {};  // all players
var g_activePlayers = [];  // players currently playing
var g_numPlayers = 0;

var g_entitySys;
var g_queueMgr;

function logTo(id, str) {
  var c = document.getElementById(id);
  var d = document.createElement("div");
  d.appendChild(document.createTextNode(str));
  c.appendChild(d);
}

function log() {
  var s = ""
  for (var ii = 0; ii < arguments.length; ++ii) {
    s += arguments[ii].toString();
  }
  logTo("console", s);
}

function connect(server, port) {
  var server = window.location.href.match(/\/\/(.*?)\//)[1];
  var port = 8080;
  g_socket = new io.Socket(null, {
      port: port,
      transports: ['websocket']});
  g_socket.connect();
  g_socket.on('message', function(obj) {
    processMessage(obj);
  });
}

function sendCmd(cmd, id, data) {
  g_socket.send({
    cmd: cmd,
    id: id,
    data: data
  });
}

function processMessage(msg) {
  switch (msg.cmd) {
  case 'start':
    startPlayer(msg.id);
    break;
  case 'update':
    updatePlayer(msg.id, msg.data);
    break;
  case 'remove':
    removePlayer(msg.id);
    break;
  }
}

function startPlayer(id) {
  if (g_players[id])
    return;

  var x = Math.random() * g_canvas.width;
  var y = Math.random() * g_canvas.height;
  var direction = Math.random() * Math.PI * 2;

  var player = new Player(x, y, direction, id);
  g_players[id] = player;
  ++g_numPlayers;
}

function getPlayer(id) {
  var player = g_players[id];
  return player;
}

function removePlayer(id) {
  if (g_players[id]) {
    g_players[id].removeFromGame();
    delete g_players[id];
    --g_numPlayers;
  }
}

function updatePlayer(id, msg) {
  var player = getPlayer(id);
  player.update(msg);
}

function makeColor(count) {
  var color = [
    (count * 0.31) % 1,
    (count * 5.73) % 1,
    (count * 7.89) % 1
  ];
  var ci = count % 3;
  for (var ii = 0; ii < 3; ++ii) {
    var ndx = (ii + ci) % 3;
    var mix = (ii == 0) ? 0.2 : 0.6;
    var max = (ii == 0) ? 1 : 0.6;
    color[ndx] = Math.floor((color[ndx] * mix + (1 - mix) * max) * 255);
  }
  return "rgb(" + color.join(",") + ")";
}

/**
 * Player represnt a player in the game.
 * @constructor
 */
function Player(x, y, direction, clientId) {
  g_entitySys.addEntity(this);
  ++g_playerCount;
  this.clientId = clientId;
  this.position = [x, y];
  this.hp = 3;
  this.color = makeColor(g_playerCount);
  sendCmd("client", clientId, {
    cmd: 'setColor',
    color: this.color
  });

  this.playerName = (++g_totalPlayerCount).toString();
  this.turn = 0;
  this.direction = direction;
  this.fire = false;
  this.vel = 200;
  this.turnVel = Math.PI * 0.5;
  this.shots = [];
  this.maxShots = 3;
  this.shotDuration = 3;
  this.shootTimer = 0;
  this.timer = 0;
  this.addToQueue();
}

Player.prototype.timesUp = function(elapsedTime) {
  this.timer -= elapsedTime;
  return this.timer <= 0;
};

Player.prototype.addToQueue = function() {
  g_queueMgr.addToQueue(this);
  this.setState('queued');
}

Player.prototype.setState = function(state) {
tdl.log(this.id, state);
  this.state = state;
  this.process = this["state_" + state];
}

Player.prototype.shoot = function() {
  if (this.shots.length >= this.maxShots) {
    var shotId = this.shots.shift();
    g_entitySys.deleteEntityById(shotId);
  }

  this.shots.push((new Shot(
    this.position[0] + -Math.sin(this.direction) * 15,
    this.position[1] +  Math.cos(this.direction) * 15,
    this.direction, this)).id);
};

Player.prototype.removeShot = function(shot) {
  var shots = [];
  for (var ii = 0; ii < this.shots.length; ++ii) {
    var s = this.shots[ii];
    if (s.id != shot.id) {
      shots.push(s);
    }
  }
  this.shots = shots;
};

Player.prototype.removeFromActive = function() {
  for (var ii = 0; ii < g_activePlayers.length; ++ii) {
    if (g_activePlayers[ii].id == this.id) {
      g_activePlayers.splice(ii, 1);
      return;
    }
  }
};

Player.prototype.removeFromGame = function() {
  g_queueMgr.removeFromQueue(this);
  this.removeFromActive();
  while (this.shots.length) {
    var shotId = this.shots.shift();
    g_entitySys.deleteEntityById(shotId);
  }
  g_entitySys.deleteEntity(this);
}

Player.prototype.update = function(msg) {
  switch (msg.cmd) {
    case 'turn':
      this.turn = msg.turn;
      break;
    case 'fire':
      this.fire = msg.fire;
      if (this.fire == 0)
        this.shootTimer = 0;
      break;
  }
};


Player.prototype.state_queued = function(elapsedTime) {
};


Player.prototype.countdown = function() {
  this.timer = 3;
  this.setState('countdown');
};

Player.prototype.state_countdown = function(elapsedTime) {
  if (this.timesUp(elapsedTime)) {
    this.timer = 0.5;
    this.setState('launch');
  }
};

Player.prototype.state_launch = function(elapsedTime) {
  if (this.timesUp(elapsedTime)) {
    g_activePlayers.push(this);
    this.setState('fly');
    g_queueMgr.removeFromQueue(this);
  }
};


Player.prototype.state_fly = function(elapsedTime) {
  this.direction += this.turnVel * this.turn * elapsedTime;
  var dx = -Math.sin(this.direction) * this.vel * elapsedTime;
  var dy =  Math.cos(this.direction) * this.vel * elapsedTime;
  updatePos(this.position, dx, dy);
  this.shootTimer = Math.max(this.shootTimer - elapsedTime, 0);
  if (this.fire && this.shootTimer <= 0) {
    this.shoot();
    this.shootTimer = this.maxShots / this.shotDuration;
  }
};

Player.prototype.die = function() {
  this.timer = 2;
  this.setState('die');
  this.removeFromActive();
};

Player.prototype.state_die = function(elapsedTime) {
  if (this.timesUp(elapsedTime)) {
    this.addToQueue();
  }
};


Player.prototype.collide = function(x, y, radius) {
  // TODO: need to put colliables on their own list or something
  // so queued players are not being checked.
  if (this.state != 'fly') {
    return false
  }
  var dx = x - this.position[0];
  var dy = y - this.position[1];
  var distSq = dx * dx + dy * dy;
  var radius = 10 + radius;
  return distSq < radius * radius;
};

Player.prototype.draw = function(ctx) {
  if (this.state != 'fly') {
    return;
  }
  ctx.save();
  ctx.translate(this.position[0], this.position[1]);
  ctx.rotate(this.direction);
  ctx.fillStyle = this.color;
  ctx.beginPath();
  ctx.closePath();
  ctx.moveTo(0, 15);
  ctx.lineTo(15, -15);
  ctx.lineTo(0, -10);
  ctx.lineTo(-15, -15);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
};

/**
 * A shot.
 * @constructor
 */
function Shot(x, y, direction, owner) {
  this.owner = owner;
  this.position = [x, y];
  this.vel = 300;
  this.duration = owner.shotDuration;
  this.direction = direction;
  this.drawCount = 0;
  g_entitySys.addEntity(this);
}

Shot.prototype.remove = function() {
  this.owner.removeShot(this);
  g_entitySys.deleteEntity(this);
};

Shot.colors = [
  "#800000",
  "#ff0000",
  "#ff8000",
  "#ffff00",
  "#ffffff",
  "#ffff00",
  "#ff0000",
  "#ff8000"
];

Shot.prototype.process = function(elapsedTime) {
  this.duration -= elapsedTime;
  if (this.duration <= 0) {
    this.remove();
  } else {
    var dx = -Math.sin(this.direction) * this.vel * elapsedTime;
    var dy =  Math.cos(this.direction) * this.vel * elapsedTime;
    updatePos(this.position, dx, dy);

    var hit = false;
    for (var ii = 0; ii < g_activePlayers.length; ++ii) {
      var player = g_activePlayers[ii];
      if (player.id != this.owner.id) {
        if (player.collide(this.position[0], this.position[1], 3)) {
          hit = true;
          player.die();
        }
      }
    }
    if (hit) {
      this.remove();
    }
  }
};

Shot.prototype.draw = function(ctx) {
  ++this.drawCount;
  ctx.save();
  ctx.translate(this.position[0], this.position[1]);
  ctx.fillStyle = Shot.colors[this.drawCount % Shot.colors.length];
  ctx.beginPath();
  ctx.closePath();
  ctx.moveTo(0, 5);
  ctx.lineTo(5, 0);
  ctx.lineTo(0, -5);
  ctx.lineTo(-5, 0);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
};


function updatePos(pos, dx, dy) {
  var x = pos[0] + dx;
  if (x < 0) {
    x = g_canvas.width - 1;
  } else if (x >= g_canvas.width) {
    x = 0;
  }

  var y = pos[1] + dy;
  if (y < 0) {
    y = g_canvas.height - 1;
  } else if (y >= g_canvas.height) {
    y = 0;
  }

  pos[0] = x;
  pos[1] = y;
}

function resizeCanvas() {
  if (g_canvas.width != g_canvas.clientWidth) {
    g_canvas.width = g_canvas.clientWidth;
    tdl.log("new width:", g_canvas.width);
  }
  if (g_canvas.height != g_canvas.clientHeight) {
    g_canvas.height = g_canvas.clientHeight;
    tdl.log("new height:", g_canvas.height);
  }
}

/**
 * Manages the Queue of players waiting.
 */
function QueueManager() {
  this.launching_ = [];
  this.queue_ = [];
  this.timer_ = 0;
  this.element_ = document.getElementById("queue");
  this.elements_ = [];
};

QueueManager.prototype.draw = function() {
  this.setElements_(0, this.launching_, true);
  this.setElements_(this.launching_.length, this.queue_, false);
  for (var ii = this.launching_.length + this.queue_.length;
       ii < this.elements_.length; ++ii) {
    var element = this.elements_[ii];
    element.innerHTML = "";
  }
};

QueueManager.prototype.getElement_ = function(index) {
  var element = this.elements_[index];
  if (!element) {
    element = document.createElement("div");
    this.element_.appendChild(element);
    this.elements_.push(element);
  }
  return element;
};

QueueManager.prototype.setElements_ = function(index, players, launching) {
  for (var ii = 0; ii < players.length; ++ii) {
    var player = players[ii];
    var element = this.getElement_(index + ii);
    if (launching) {
      element.innerHTML = "Launch: " + player.playerName;
    } else {
      element.innerHTML = "Waiting: " + player.playerName;
    }
  }
};

QueueManager.prototype.addToQueue = function(player) {
  this.queue_.push(player);
  this.draw();
};

QueueManager.prototype.removeFromQueue = function(player) {
  for (var ii = 0; ii < this.queue_.length; ++ii) {
    if (this.queue_[ii].id == player.id) {
      this.queue_.splice(ii, 1);
      this.draw();
      return;
    }
  }
  for (var ii = 0; ii < this.launching_.length; ++ii) {
    if (this.launching_[ii].id == player.id) {
      this.launching_.splice(ii, 1);
      this.draw();
      return;
    }
  }
};

QueueManager.prototype.process = function(elapsedTime) {
  if (this.timer_ > 0) {
    this.timer_ -= elapsedTime;
  } else {
    if (this.queue_.length > 0 &&
        g_activePlayers.length + this.launching_.length < g_maxActivePlayers) {
      var player = this.queue_.shift()
      player.countdown();
      this.launching_.push(player);
      this.timer_ = 1;  // don't start another for at least 1 second.
      this.draw();
    }
  }
};

/**
 * Processes and Draws all the entities.
 * An entity is currently losely defined as any object that has
 * a process and a draw function.
 */
function EntitySystem() {
  this.entities_ = {};
  this.numEntities_ = 0;
  this.nextId_ = 1;
  this.removeEntities_ = [];
}

EntitySystem.prototype.addEntity = function(entity) {
  var id = this.nextId_++;
  entity.id = id;
  this.entities_[id] = entity;
  ++this.numEntities_;
};

EntitySystem.prototype.deleteEntity = function(entity) {
  this.deleteEntityById(entity.id);
};

EntitySystem.prototype.deleteEntityById = function(id) {
  this.removeEntities_.push(id);
};

EntitySystem.prototype.processEntities = function(elapsedTime) {
  for (var id in this.entities_) {
    this.entities_[id].process(elapsedTime);
  }
  while (this.removeEntities_.length) {
    delete this.entities_[this.removeEntities_.pop()];
    --this.numEntities_;
  }
};

EntitySystem.prototype.drawEntities = function(ctx) {
  for (var id in this.entities_) {
    this.entities_[id].draw(ctx);
  }
};

function main() {
  g_canvas = document.getElementById("canvas");
  g_ctx = g_canvas.getContext("2d");
  connect();
  sendCmd("server");

  g_entitySys = new EntitySystem();
  g_queueMgr = new QueueManager();

  var then = (new Date()).getTime() * 0.001;
  render();

  function render() {
    var now = (new Date()).getTime() * 0.001;
    var elapsedTime = now - then;
    then = now;
    tdl.webgl.requestAnimationFrame(render, canvas);

    g_queueMgr.process(elapsedTime);
    g_entitySys.processEntities(elapsedTime);

    resizeCanvas();
    g_ctx.clearRect(0, 0, g_canvas.width, g_canvas.height);
    g_entitySys.drawEntities(g_ctx);
  }

}
</script>
</head>
<body>
<div id="outer">
  <canvas id="canvas"></canvas>
  <div id="status">
    <div id="highscores-outer">
      <div class="headline">High Score</div>
      <div id="highscore"></div>
    </div>
    <div id="queue-outer">
      <div class="headline">Waiting</div>
      <div id="queue"></div>
    </div>
  </div>
</div>
</body>
</html>

